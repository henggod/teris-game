<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        accent: '#F59E0B',
                        dark: '#1F2937',
                        light: '#F3F4F6'
                    },
                    fontFamily: {
                        game: ['"Press Start 2P"', 'cursive', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .game-shadow {
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
            }
            .btn-hover {
                @apply transition-all duration-200 hover:scale-105 active:scale-95;
            }
        }
    </style>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            background-color: #111827;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(59, 130, 246, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(16, 185, 129, 0.1) 0%, transparent 20%);
            min-height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            background-color: #1F2937;
            border: 4px solid #374151;
            border-radius: 4px;
        }
        
        .control-icon {
            transform: scale(0.8);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-4 text-light">
    <div class="text-center mb-6">
        <h1 class="text-[clamp(1.8rem,5vw,2.5rem)] font-bold text-primary mb-2 tracking-wider">俄罗斯方块</h1>
        <p class="text-gray-400 text-sm">使用方向键控制，上键旋转，下键加速下落</p>
    </div>

    <div class="flex flex-col md:flex-row gap-6 items-center md:items-start">
        <!-- 游戏区域 -->
        <div class="game-shadow rounded-lg p-4 bg-dark/80 backdrop-blur-sm">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
        </div>
        
        <!-- 游戏信息和控制 -->
        <div class="w-full md:w-64 flex flex-col gap-4">
            <!-- 分数显示 -->
            <div class="game-shadow rounded-lg p-4 bg-dark/80 backdrop-blur-sm">
                <h2 class="text-lg font-bold text-center mb-3 text-accent">分数</h2>
                <div class="text-center">
                    <span id="score" class="text-3xl font-bold text-light">0</span>
                </div>
            </div>
            
            <!-- 控制按钮 -->
            <div class="game-shadow rounded-lg p-4 bg-dark/80 backdrop-blur-sm">
                <h2 class="text-lg font-bold text-center mb-3 text-accent">控制</h2>
                <button id="startBtn" class="w-full py-3 bg-secondary text-white rounded-lg font-bold btn-hover mb-2 flex items-center justify-center gap-2">
                    <i class="fa fa-play"></i> 开始
                </button>
                <button id="resetBtn" class="w-full py-3 bg-primary text-white rounded-lg font-bold btn-hover flex items-center justify-center gap-2">
                    <i class="fa fa-refresh"></i> 重置
                </button>
            </div>
            
            <!-- 游戏说明 -->
            <div class="game-shadow rounded-lg p-4 bg-dark/80 backdrop-blur-sm text-sm">
                <h2 class="text-lg font-bold text-center mb-3 text-accent">操作说明</h2>
                <div class="space-y-2">
                    <div class="flex items-center justify-between">
                        <span>左移</span>
                        <span class="bg-gray-700 px-2 py-1 rounded control-icon"><i class="fa fa-arrow-left"></i></span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>右移</span>
                        <span class="bg-gray-700 px-2 py-1 rounded control-icon"><i class="fa fa-arrow-right"></i></span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>旋转</span>
                        <span class="bg-gray-700 px-2 py-1 rounded control-icon"><i class="fa fa-arrow-up"></i></span>
                    </div>
                    <div class="flex items-center justify-between">
                        <span>加速下落</span>
                        <span class="bg-gray-700 px-2 py-1 rounded control-icon"><i class="fa fa-arrow-down"></i></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 游戏配置
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        let canvas, ctx;
        let score = 0;
        let gameInterval;
        let gameSpeed = 1000; // 初始下落速度(毫秒)
        let isGameOver = false;
        let isPlaying = false;

        // 方块形状定义 (I, O, T, L, J, S, Z)
        const SHAPES = [
            [[1, 1, 1, 1]], // I
            [[1, 1], [1, 1]], // O
            [[0, 1, 0], [1, 1, 1]], // T
            [[0, 0, 1], [1, 1, 1]], // L
            [[1, 0, 0], [1, 1, 1]], // J
            [[0, 1, 1], [1, 1, 0]], // S
            [[1, 1, 0], [0, 1, 1]]  // Z
        ];

        // 方块颜色
        const COLORS = [
            '#3B82F6', // 蓝色
            '#10B981', // 绿色
            '#F59E0B', // 黄色
            '#EF4444', // 红色
            '#8B5CF6', // 紫色
            '#EC4899', // 粉色
            '#06B6D4'  // 青色
        ];

        // 游戏区域
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        
        // 当前方块
        let currentShape;
        let currentColor;
        let currentX;
        let currentY;

        // 初始化游戏
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 重置游戏状态
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            updateScore();
            isGameOver = false;
            
            // 创建新方块
            createNewShape();
            drawBoard();
            
            // 事件监听
            document.addEventListener('keydown', handleKeyPress);
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
        }

        // 创建新方块
        function createNewShape() {
            const random = Math.floor(Math.random() * SHAPES.length);
            currentShape = SHAPES[random];
            currentColor = COLORS[random];
            
            // 初始位置
            currentX = Math.floor(COLS / 2) - Math.floor(currentShape[0].length / 2);
            currentY = 0;
            
            // 检查游戏是否结束
            if (isColliding()) {
                isGameOver = true;
                stopGame();
                alert('游戏结束！得分: ' + score);
            }
        }

        // 绘制游戏区域
        function drawBoard() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制已落下的方块
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(x, y, board[y][x]);
                    }
                }
            }
            
            // 绘制当前方块
            for (let y = 0; y < currentShape.length; y++) {
                for (let x = 0; x < currentShape[y].length; x++) {
                    if (currentShape[y][x]) {
                        drawBlock(currentX + x, currentY + y, currentColor);
                    }
                }
            }
        }

        // 绘制单个方块
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            
            // 绘制高光效果
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, 4);
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, 4, BLOCK_SIZE - 1);
            
            // 绘制阴影效果
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE + BLOCK_SIZE - 5, BLOCK_SIZE - 1, 4);
            ctx.fillRect(x * BLOCK_SIZE + BLOCK_SIZE - 5, y * BLOCK_SIZE, 4, BLOCK_SIZE - 1);
        }

        // 检查碰撞
        function isColliding(offsetX = 0, offsetY = 0, newShape) {
            const shape = newShape || currentShape;
            
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newX = currentX + x + offsetX;
                        const newY = currentY + y + offsetY;
                        
                        // 检查是否超出边界或与已有方块碰撞
                        if (
                            newX < 0 || 
                            newX >= COLS || 
                            newY >= ROWS || 
                            (newY >= 0 && board[newY][newX])
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 旋转方块
        function rotateShape() {
            // 创建旋转后的形状 (顺时针旋转90度)
            const rotated = [];
            for (let x = 0; x < currentShape[0].length; x++) {
                const row = [];
                for (let y = currentShape.length - 1; y >= 0; y--) {
                    row.push(currentShape[y][x]);
                }
                rotated.push(row);
            }
            
            // 检查旋转后是否碰撞
            if (!isColliding(0, 0, rotated)) {
                currentShape = rotated;
            } else if (!isColliding(-1, 0, rotated)) {
                // 尝试向左偏移
                currentX--;
                currentShape = rotated;
            } else if (!isColliding(1, 0, rotated)) {
                // 尝试向右偏移
                currentX++;
                currentShape = rotated;
            }
            
            drawBoard();
        }

        // 移动方块
        function move(dx, dy) {
            if (!isColliding(dx, dy)) {
                currentX += dx;
                currentY += dy;
                drawBoard();
                return true;
            } else if (dy > 0) {
                // 如果下移时碰撞，锁定当前方块
                lockShape();
                clearLines();
                createNewShape();
                drawBoard();
                return false;
            }
            return false;
        }

        // 锁定方块到游戏区域
        function lockShape() {
            for (let y = 0; y < currentShape.length; y++) {
                for (let x = 0; x < currentShape[y].length; x++) {
                    if (currentShape[y][x]) {
                        const newY = currentY + y;
                        if (newY >= 0) {
                            board[newY][currentX + x] = currentColor;
                        }
                    }
                }
            }
        }

        // 消除完整的行
        function clearLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                let isLineComplete = true;
                
                for (let x = 0; x < COLS; x++) {
                    if (!board[y][x]) {
                        isLineComplete = false;
                        break;
                    }
                }
                
                if (isLineComplete) {
                    // 移除当前行并在顶部添加新行
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    y++; // 检查新移到当前位置的行
                    linesCleared++;
                }
            }
            
            // 根据消除的行数加分
            if (linesCleared > 0) {
                score += linesCleared * 100 * linesCleared; // 消除的行数越多，得分倍数越高
                updateScore();
                
                // 随分数增加游戏速度
                gameSpeed = Math.max(100, 1000 - Math.floor(score / 1000) * 100);
                if (isPlaying) {
                    stopGame();
                    startGame();
                }
            }
        }

        // 更新分数显示
        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        // 处理键盘事件
        function handleKeyPress(e) {
            if (!isPlaying || isGameOver) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    move(-1, 0);
                    break;
                case 'ArrowRight':
                    move(1, 0);
                    break;
                case 'ArrowDown':
                    move(0, 1);
                    break;
                case 'ArrowUp':
                    rotateShape();
                    break;
            }
        }

        // 方块自动下落
        function drop() {
            move(0, 1);
        }

        // 开始游戏
        function startGame() {
            if (isGameOver) {
                resetGame();
            }
            
            if (!isPlaying) {
                isPlaying = true;
                gameInterval = setInterval(drop, gameSpeed);
                document.getElementById('startBtn').innerHTML = '<i class="fa fa-pause"></i> 暂停';
            } else {
                stopGame();
                document.getElementById('startBtn').innerHTML = '<i class="fa fa-play"></i> 继续';
            }
        }

        // 停止游戏
        function stopGame() {
            isPlaying = false;
            clearInterval(gameInterval);
        }

        // 重置游戏
        function resetGame() {
            stopGame();
            init();
            document.getElementById('startBtn').innerHTML = '<i class="fa fa-play"></i> 开始';
        }

        // 页面加载完成后初始化游戏
        window.onload = init;
    </script>
</body>
</html>
